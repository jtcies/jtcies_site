---
title: Extending luck
author: 'Joe Ciesielski'
date: '2018-03-29'
slug: extending-luck
categories: []
tags: []
comments: no
showcomments: yes
showpagemeta: yes
draft: true
---
First we set up the experiment

```{r}
library(tidyverse)
library(gganimate)
library(data.table)

set.seed(2018)

# set the environment variables
n = 1000 # number of individuals
c = 10 # starting captial
m = 0.6 # mean talent
sd = 0.1 # std dev talent
i = 80 - 1 # number of iterations (years times two for each six months,
 # minus 1 because time zero is already incorporated)
ne = 500 # number of lucky/unlucky events
pl = 0.5 # probability of lucky events

t = rnorm(n, m, sd) # talent
e = sample(c(-1,1), ne, prob = c(1 - pl, pl), replace = TRUE) # events

# set the coordinates for the invididuals and events
nx <- sample.int(1000, size = n, replace = TRUE)
ny <- sample.int(1000, size = n, replace = TRUE)

qplot(nx, ny) # make sure spread of individuals looks good

agents <- data.frame(nx, ny, t, c)

ex <- sample.int(1000, size = ne, replace = TRUE)
ey <- sample.int(1000, size = ne, replace = TRUE)


ggplot(data.frame(ex, ey, e), aes(ex, ey, color = factor(e))) +
  geom_point() # make sure events look good

# now try with multiple random walks

rand_walk <- function(xstart, ystart, xwalks, ywalks){
  xwalks <- c(xstart, xwalks) %>% cumsum()
  ywalks <- c(ystart, ywalks) %>% cumsum()
  cbind(xwalks, ywalks)
}

walks <- data.frame(
  a = sample(c(-1, 1), ne * i, TRUE),
  b = sample(c(-1, 1), ne * i, TRUE)
) %>% 
  split(1:ne)

event_walks <- data.frame(ex, ey) %>% 
  split(1:ne) %>% 
  map2(walks, ~ rand_walk(.x$ex, .x$ey, .y$a, .y$b)) %>% 
  map_df(~ transform(.x, step = 0:i)) %>% 
  mutate(event_num = rep(1:ne, each = i + 1),
         luck = rep(e, each = i + 1))

sample_events <- sample(c(1:500), 10)

event_walks %>% 
  filter(event_num %in% sample_events) %>% 
  ggplot(aes(xwalks, ywalks, color = factor(event_num * luck), 
             group = event_num, alpha = step)) +
    geom_path()
  
```

Next determine which events intersected with which agents.

```{r}

intersect <- function(x) {
  for (i in 0:i + 1) {
    
    this_step <- event_walks[event_walks$step == i, ]
    
    agents <- left_join(agents, this_step, 
                        by = c("nx" = "xwalks", "ny" = "ywalks"))
    
    agents <- agents %>% 
      replace_na(replace = list(luck = 0)) %>% 
      mutate(
        c = case_when(
          luck == 1  & runif(1) < t ~ c * 2,
          luck == -1 & runif(1) > t ~ c / 2,
          TRUE                      ~ c)
      ) %>% 
      select(nx, ny, t, c) %>% 
      distinct(nx, ny, .keep_all = TRUE)
  }
  agents
}

experiment <- intersect()

summary(experiment$c)

```

Histogram of capital after experiment. 

```{r}

ggplot(experiment, aes(c + 1)) + 
  geom_histogram(binwidth = 50) +
  scale_y_log10()

```


Plot the amount of capital as a size of the agents.

```{r}

ggplot(experiment, aes(nx, ny, size = c)) +
  geom_point()

```

This model operates on a couple of assumptions. First, that intelligence in normally distrubted and that higher intelligence is what allows somewhat to take advantage of a lucky event or not be harmed by an unlucky event. Additionally, it assumes that (un)lucky events follow a random pattern. 

I'm interested in testing a different set of assumptions. Namely, events do not follow a random pattern but are systematically located around specific individuals. 

```{r}

# same random events and same agent locations

events <- data.frame(ex, ey, luck = e)

agents <- data.frame(nx, ny, c)

rep_data <- function(df, rep) {
 df[rep(1:nrow(df), each = rep), ]
}

experiment2 <- function(events, agents, steps) {
  
  for (i in 1:steps) {
    intersection <- left_join(agents, events, 
                              by = c("nx" = "ex",
                                     "ny" = "ey")) %>% 
      replace_na(replace = list(luck = 0)) %>% 
      mutate(
        c = case_when(
          luck ==  1 & runif(1) >= 0.5 ~ c * 2,
          luck == -1 & runif(1) <= 0.5 ~ c / 2, 
          TRUE ~ c)
      )
    
    lucky <- intersection %>% 
      filter(luck == 1) %>% 
      mutate(
        dup = case_when(
          runif(1) >= 0.75 ~ 2L,
          TRUE             ~ 1L
        )
      ) %>% 
      select(ex = nx, ey = ny, dup)
    
    events <- left_join(events, lucky, by = c("ex", "ey")) %>% 
      replace_na(replace = list(dup = 1L))
    
    events <- events %>% 
      split(1:nrow(.)) %>% 
      map_dfr(~rep_data(., .$dup))
    
    agents <- select(intersection, nx, ny, c) %>% 
      distinct(nx, ny, .keep_all = TRUE)
    
    xwalk <- sample(c(-1, 1), nrow(events), replace = TRUE)
    ywalk <- sample(c(-1, 1), nrow(events), replace = TRUE)
    
    events <- events %>%
      mutate(
        ex = ex + xwalk,
        ey = ey + ywalk,
      ) %>% 
      select(ex, ey, luck)
    
  }
  as_tibble(agents)
}

experiment2(events, agents, 15)

```

```{r}

match_up <- function(ax, ay, bx, by) {
  ret <- vector(length = length(ax))
  for(i in 1:length(ax)) {
    for (j in 1:length(bx)) {
      if(ax[i] == bx[j] && ay[i] == by[j]) {
        log <- TRUE
      } else {
        log <- FALSE
      }
      ret[i] <- log
    }
  }
  ret
}

matches <- match_up(x, y, a, b)
```

```{r}
events <- data.frame(ex, ey, luck = e) %>% 
  data.table(key = "ex,ey")

agents <- data.frame(nx, ny, c) %>% 
  data.table(key = "nx,ny")

match_2 <- function(agents, events, rep) {
 
  walk <- function(a) {
   a <- a + sample(c(-1, 1), 1)
   a
  }
  
  for (i in 1:rep) {
    # match up the agents and events that intersect
    setkeyv(events, c("ex", "ey"))
    agents <- unique(agents)
    agents <- data.table(agents)
    setkeyv(agents, c("nx", "ny"))
    ret <- events[agents]
    ret$luck[is.na(ret$luck)] <- 0
    ret$c <- ifelse(ret$luck == 1 & runif(1) >= 0.5, ret$c * 2, ret$c)
    ret$c <- ifelse(ret$luck == -1 & runif(1) < 0.5, ret$c / 2, ret$c)
    agents <- ret[, .(nx = ex, ny = ey, c)]

    # duplicate some of the events that are lucky
    ret$dup <- ifelse(ret$luck == 1 & runif(1) >= 0.75, 2, 1)
    duplicate <- ret[, .(ex, ey, dup)]
    setkeyv(duplicate, c("ex", "ey"))
    events <- duplicate[events]
    events$dup[is.na(events$dup)] <- 1
    events <- events[rep(1:nrow(events), events$dup), ]
    events <- events[, c("ex", "ey", "luck")]
    
    # walk the events
    events$ex <- map_dbl(events$ex, walk)
    events$ey <- map_dbl(events$ex, walk)
     
  }
  agents 
}

tmp <- match_2(agents, events, 20)
```

