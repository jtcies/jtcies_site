---
draft: true
title: When does garbage time start? 
author: Joe Ciesielski
date: '2020-01-14'
tags:
  - R
  - NBA
output: html_document
---

The 76ers recent Christmas Day game agains the Milwaukee Bucks got me thinking about garbage time. The Sixers held a fairly substantial lead for the whole game, but let it get close at the end (they were outscored by 15 points in the fourth quarter). 

I started to wonder, "When does garbage time start"? According to Wikipedia:

> Garbage time is a term used to refer to the period toward the end of a timed sports competition that has become a blowout when the outcome of the game has already been decided, and the coaches of one or both teams will decide to replace their best players with substitutes.

There's two questions in there. First, when is the outcome of the game decided? Second, when do coaches decide to replace their best players with substitute?

I'll take a look at these questions using the `tidyverse` for data manipulation, `nbastatR` for getting play-by-play data from the 2018-19 NBA regular season, and the `rethinking` package (which provides and interface to Stan) for modeling. 

## Setup

```{r setup, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, 
                      fig.align = "center", fig.width = 8, fig.asp = 0.618)

library(tidyverse)
library(nbastatR)
library(rethinking)
library(googledrive)
library(survival)
#devtools::instal_github("jtcies/jtcr")
library(jtcr)

theme_set(theme_jtc())

# your email address
drive_auth(email = "jtcies@gmail.com")

```

First we'll take grab the play-by-play for the first game from the 2018-19 regular seaons. 

```{r}

games <- seasons_schedule(seasons = 2019)

game_ids <- games$idGame

game_1  <- game_ids[[1]]

game_1_pbp <- play_by_play_v2(game_1)

game_1_pbp

```

Ah yes, I remember this game - Sixers lost to the Celtics. 

The first question we'll look is when does the coach decides to put in their substitutes, presumably because the outcome of the game has been decided and they want their less experienced players to get experience. To analyze this, we should take look at when a  

```{r g1firstaction}

game_1_first_action <- game_1_pbp %>%
    filter(!is.na(namePlayer1), !is.na(namePlayer2)) %>%
    mutate(player1 = paste0(slugTeamPlayer1, "_", namePlayer1),
           player2 = paste0(slugTeamPlayer2, "_", namePlayer2)) %>%
    select(player1, player2, minuteGame, numberPeriod) %>%
    gather(drop, player, 1:2) %>%
    select(-drop) %>%
    group_by(player) %>%
    filter(minuteGame == min(minuteGame), !is.na(player)) %>%
    arrange(minuteGame) %>%
    group_by(team = str_sub(player, 1, 3)) %>%
    mutate(player_count = row_number(),
           player = str_replace(player, "^[A-Z]{3}_", "")) %>%
    arrange(team)

knitr::kable(game_1_first_action)
```

Philadedelphia played 11 unique players, while Boston played 13 (a team can have up to 14). For Philly, the 9 players played in the first half, but 10 and 11 came in in the last two minutes of the game. For Boston, 9 also played in the first half, one showed up on the 3rd quarter, and 3 came in right at the end. How did the game end again? 

```{ri g1gt}

game_1_pbp %>% 
    fill(scoreAway, scoreHome, marginScore) %>%
    filter(minuteGame == 46.55) %>%
    select(scoreAway, scoreHome, marginScore)  %>%
    distinct() %>%
    knitr::kable()

```

Right... 

Ok, so I think there's a few things we need to figure out. First, how far in list of available players does a coach have to go before we consider them to resigned the outcome the of game. And once we figure out that number, what is the combination of score margin and time left that coaches typically reach that far in their bench. 

Below is function that gets the time of first appearance for each player, the running total of unique players that each substitute represents, and the score margin when they checked in. 

```{r gtfun}

get_player_starts <- function(game_pbp) {

    player_starts <- game_pbp %>%
        fill(marginScore) %>%
        filter(!is.na(namePlayer1), !is.na(namePlayer2)) %>%
        mutate(player1 = paste0(slugTeamPlayer1, "_", namePlayer1),
               player2 = paste0(slugTeamPlayer2, "_", namePlayer2)) %>%
        select(player1, player2, minuteGame, marginScore, idGame) %>%
        gather(drop, player, 1:2) %>%
        separate(player, into = c("team", "player"), sep = "_") %>%
        select(-drop) %>%
        group_by(player) %>%
        filter(minuteGame == min(minuteGame)) %>%
        group_by(team) %>%
        mutate(n_player = row_number()) %>%
        replace_na(list(marginScore = 0))
        
}

get_player_starts(game_1_pbp) %>%
    knitr::kable()
```

Whena applying that function to the first game, we can see that garbage time started when the 10th Philadelphia and 11th Boston player came in - about a minute and half left and Boston up by 16. Now that we know it works, we can apply to it each gmae of the season. 

```{r getgt}
# you can use this below to download yourself
# it's a big file so I've uploaded it to my google drive 

# game_ids <- games$idGame

# games_pbp <- purrr::map_dfr(game_ids, play_by_play_v2)

# if you want to download yourself, you can use this code
#game_ids <- games$idGame

# games_pbp <- purrr::map_dfr(game_ids, play_by_play_v2)

# i've already uploaded the full play by play for 2019 to my google drive. 
# you can access here: https://drive.google.com/open?id=1J4oHD-8ILt9nOAVgw8GoEyBtct8BO4y8

temp_dir <- tempdir()

drive_download(
    file = as_id("1J4oHD-8ILt9nOAVgw8GoEyBtct8BO4y8"),
    path = file.path(temp_dir, "nba_pbp_2019.csv"),
    overwrite = TRUE
)

games_pbp <- read_csv(file.path(temp_dir, "nba_pbp_2019.csv"))

# length(unique(games_pbp$idGame))
# [1] 1227 -  missing three games

player_starts <- games_pbp %>% 
    split(.$idGame) %>% 
    map_dfr(get_player_starts)
```

```{r}

player_starts %>%
    filter(minuteGame < 48,
           n_player > 5) %>%
    ggplot(aes(minuteGame, abs(marginScore))) +
        geom_jitter() +
        facet_wrap(~n_player) +
        xlim(c(0, 48)) +
        annotate("rect", xmin = 36, ymin = 10, xmax = 48, ymax = Inf,
                  alpha = 0.2, fill = "red") +
        annotate("rect", xmin = 45, ymin = 0, xmax = 48, ymax = Inf,
                  alpha = 0.2, fill = "blue") +
        labs(y = "Score margin",
             x = "minute",
             title = "First appearance of teams substitutes")

```

The chart above shows the first appearance of each teams 6th through 14th players. The red block shows the last quarter and margin of at least 10, and the blue shows the last three minutes. These are just to highlight the most conservative estimates of garbage time. 

For these purposes, it looks like we say that it's garbage time if the 10th player sees their first action in the fourth quarter with a margin of at least 10 points or if the 10th player sees their first action with less than three minutes left in the game. If we just went with the 10th player, we'd capture too many games where the 10th player checks in during the first half, which would never be considered garbage time. If we went with the 13th or 14th player, we'd miss a whole bunch of games that never saw that many unique players. So combination is required. 

Let's apply that definition to all of the games to see when garbage time starts or what the final margin was if it didn't happen. 

```{r}
gt_start <- player_starts %>%
    group_by(idGame) %>%
    filter(n_player == 12, 
           max(minuteGame) <= 48, # no ot
           minuteGame >= 36) %>%
    filter(minuteGame == min(minuteGame)) %>%
    ungroup() %>%
    distinct(minuteGame, idGame, marginScore) %>%
    select(idGame, gt_start = minuteGame, gt_margin = marginScore)

fill_margin <- function(dat){

    dat %>%
        fill(marginScore) %>%
        replace_na(list(marginScore = 0))
    
}

pbp_gt <- games_pbp %>%
    group_by(idGame) %>%
    filter(max(minuteGame) <= 48) %>%
    ungroup() %>%
    split(.$idGame) %>%
    map_dfr(fill_margin) %>%
    left_join(gt_start, by = "idGame") %>%
    mutate(
        gt = case_when(
            is.na(gt_start) ~ 0L,
            minuteGame >= gt_start ~ 1L,
            TRUE ~ 0L
        )
    )

```

Now we have play-by-play for each game and whether garbage time had kicked in. 

What is was the score margin and time when garbage time began? 

```{r}

pbp_gt %>%
    filter(gt == 1) %>%
    group_by(idGame) %>%
    arrange(minuteGame, desc(marginScore)) %>%
    distinct(idGame, .keep_all = TRUE) %>%
    select(idGame, marginScore, minuteGame) %>%
    ggplot(aes(minuteGame, abs(marginScore))) +
        geom_point()

```

What percent of games go into garbage time? 

```{r}

pbp_gt %>%
    mutate(minuteGame = round(minuteGame, 1)) %>%
    arrange(minuteGame, desc(gt)) %>%
    distinct(idGame, minuteGame, .keep_all = TRUE) %>%
    complete(idGame, minuteGame)  %>%
    fill(gt) %>%
    replace_na(list(gt = 0)) %>%
    group_by(minuteGame) %>%
    summarise(pct = mean(gt)) %>%
    ggplot(aes(minuteGame, pct)) +
        geom_line()

```

## Modeling

We'll approach this modeling in three different ways. 

1. Survival analysis: what percent of games have not yet entered garbage time given the score? 
2. Regression: what is the relationship between game time and score margin when garbage time starts? 
3. When is a game decided (how likely is that the the team ahead at a given point and score margin will finish the game as the winner)? 

## Regression model

```{r}

reg_df <- pbp_gt %>%
    group_by(idGame) %>%
    filter(gt == 1) %>%
    arrange(minuteGame) %>%
    distinct(idGame, .keep_all = TRUE) %>%
    select(idGame, minuteGame, marginScore, gt) %>%
    mutate(marginScore = abs(marginScore))

reg_list <- list(
    t = reg_df$minuteGame,
    m = reg_df$marginScore
)

set.seed(2020)
    
reg_mod <- ulam(
    alist(
        m ~ normal(mu, sigma),
        mu <- a + -exp(t * b1),
        sigma ~ exponential(1),
        b1 ~ normal(0, 0.01),
        a ~ exponential(1)
    ),
    data = reg_list,
    chains = 4,
    cores = parallel::detectCores()
)

precis(reg_mod)

```

```{r}

pred_df <- tibble(t = seq(0, 48, by = 0.1))

reg_preds <- link(reg_mod, pred_df)

pred_mean <- apply(reg_preds, 2, mean)
pred_ci <- apply(reg_preds, 2, PI)

pred_df %>%
    mutate(
        mean = pred_mean,
        low = pred_ci[1, ],
        high = pred_ci[2, ]
    ) %>%
    ggplot(aes(t, mean)) +
        geom_line() +
        geom_point(data = reg_df, aes(minuteGame, marginScore)) +
        geom_ribbon(aes(ymin = low, ymax = high), alpha = 0.2) +
        scale_x_continuous(limits = c(36, 48)) +
        labs(
            x = "game minute",
            y = "score margin",
            title = "Predicted score margin of entering garbage time"
        )

```

### Survival analysis

First, we will create a data frame the keeps a record of each j

```{r}

surv_df <- pbp_gt %>%
    mutate(minuteGame = round(minuteGame, 1)) %>%
    arrange(minuteGame, desc(gt)) %>%
    distinct(idGame, minuteGame, .keep_all = TRUE) %>%
    complete(idGame, minuteGame)  %>%
    fill(gt, marginScore) %>%
    replace_na(list(gt = 0, marginScore = 0)) %>%
    group_by(idGame, gt) %>%
    mutate(
        keep = case_when(
            gt == 0 & minuteGame == 48 ~ 1, 
            gt == 1 & minuteGame == min(minuteGame) ~ 1,
            TRUE ~ 0
        )
    ) %>%
    filter(keep == 1) %>%
    ungroup() %>%
    select(idGame, minuteGame, marginScore, gt)


cox_fit <- coxph(Surv(minuteGame, gt) ~ log(marginScore), data = surv_df)

cox_sim <- crossing(
  marginScore = seq(0, 30, by = 5)
)

cox_pred <- survfit(cox_fit, newdata = cox_sim)

cox_df <- as_tibble(cox_pred$cumhaz)

colnames(cox_df) <- cox_sim$marginScore

surv_preds <- cox_df %>%
    mutate(minuteGame = cox_pred$time) %>%
    gather(margin, haz_prob, -minuteGame, convert = TRUE)

surv_preds %>%
    mutate(margin = fct_rev(factor(margin))) %>%
    ggplot(aes(minuteGame, haz_prob, color = margin)) +
        geom_line(size = 1.5) +
        scale_y_continuous(limits = c(0, NA), labels = scales::percent) +
        labs(
            title = "Cumulative hazard curves for garbage time based on Cox Hazard model of score margins",
            y = "cumulative hazard of entering garbage time",
            x = "minute in game",
            color = "score margin"
        )

```

While this works, it seems to overestimate the probability low scoring games have garbage time. A game with 0 score margin should never enter garbage time. Let's try a different technique. 


### When is a game decided? 

The other way to look at garbage time is to examine at what point the outcome is already decided. Below I calculate the margin above which a percentage of games end with the leading team winning. I use a 90%, 95%, and 99% threshold.

```{r}

scores_df <- games_pbp %>%
    mutate(minuteGame = round(minuteGame, 1)) %>%
    complete(idGame, minuteGame = seq(0, 48, by = 0.1)) %>%
    group_by(idGame) %>%
    fill(marginScore) %>%
    replace_na(list(marginScore = 0)) %>%
    arrange(minuteGame, desc(marginScore)) %>%
    distinct(idGame, minuteGame, .keep_all = TRUE) %>%
    select(idGame, minuteGame, marginScore) %>%
    filter(minuteGame <= 48) %>%
    ungroup()

final_scores <- scores_df %>%
    group_by(idGame) %>%
    filter(minuteGame == max(minuteGame)) %>%
    distinct(idGame, .keep_all = TRUE) %>% 
    select(idGame, final_score = marginScore)

scores_w_final <- scores_df %>%
    inner_join(final_scores, by = "idGame") %>%
    transmute(
        home_margin = marginScore,
        away_margin = -marginScore,
        home_final = final_score,
        away_final = -final_score,
        idGame,
        minuteGame
    ) %>%
    gather(metric, margin, -idGame, -minuteGame) %>%
    separate(metric, c("team", "type")) %>%
    spread(type, margin) %>% 
    mutate(
        win = final > 0
    ) %>%
    filter(margin >= 0)

win_mod <- glm(
    win ~ exp(margin) + margin:minuteGame + minuteGame:team + team,
    data = scores_w_final,
    family = "binomial"
)

win_preds <- crossing(
    minuteGame = seq(0, 48, by = 0.1),
    margin = seq(0, 30, by = 5),
    team = c("home", "away")
) %>%
    broom::augment(win_mod, newdata = ., type.predict = "response") %>% 
    rename(win_prob = .fitted, win_se = .se.fit)

win_preds %>%
    mutate(margin = fct_rev(factor(margin))) %>%
    ggplot(aes(minuteGame, win_prob, color = factor(margin), linetype = team)) +
        geom_line(size = 1.5) +
        scale_y_continuous(labels = scales::percent, limits = c(0, 1)) +
        labs(
            title = "Probability that games the winning team at time will win game",
            y = "probability of winning",
            x = "game minute",
            color = "current margin",
            linetype = ""
        )

```

There are a few interesting things happening here. You can see the home team's advantage diminishing over time. Games with a 30 point margin are basically decided at half time, and overcoming a 20 point deficit in the 4th quarter is quite rare. However, there are a few issues with this model. I belive the home and away margin should converge at the end of regulation and that all other margins should be at 1 at minute 48. These are limitations of how we defined our model. 

### Putting it together


```{r}

win_preds %>%
  left_join(surv_preds, by =c("margin", "minuteGame")) %>% 
  select(-win_se) %>%
  gather(metric, val, win_prob:haz_prob) %>% 
  mutate(team = if_else(metric == "haz_prob", "away", team)) %>% 
  group_by(metric, margin) %>% 
  arrange(minuteGame) %>% 
  fill(val) %>%
  replace_na(list(val = 0)) %>% 
  ggplot(aes(minuteGame, val,linetype = team, color = metric)) +
    geom_line(size = 1.5) +
    geom_hline(yintercept = 1, linetype = 2, alpha = 0.5, color = jtc_primary[[1]]) +
    facet_wrap(~ margin) +
    scale_x_continuous(limits = c(0, 48), breaks = seq(0, 48, by = 12)) +
    scale_y_continuous(
      limits = c(0, 1.25), labels = scales::percent,
      breaks = seq(0, 1, by = 0.25)
    ) +
    scale_color_discrete(labels = c("cumulative hazard", "win probability")) +
    labs(
      linetype = "",
      color = "",
      y = "",
      x = "game minute",
      title = "Coaches only put in deep bench reserves well after game is decided"
    ) 

```

This implies that coaches are more conservative than necessary in their assesment of 


## Other questions

There are a number of other questions that would be interesting to explore in this problem. 

- What are other ways to define garbage time start (than a player's first action)? 
- How do coaches differ in whether or not they go into garbage time mode? 
- How does the time of season factor in? 
- Has the boundry for garbage time changed over time? 
- How close does the score have to get for a coach to put their starters back in? 
- How to factor in games going to overtime? 

## Conclusion

I set out here to examine the question of when garbage time does and should start. As I went along, I became interested in how the different problem definitions led to different modeling choices. Each of the models we created is imperfect in some way and could be improved. However, it is important to understand how each model represents a different formulation of the question, and ultimately that formulation should be driven by the decision that needs to be made. 






