---
draft: true
title: When does garbage time start? 
author: Joe Ciesielski
date: '2020-01-14'
tags:
  - R
  - NBA
output: html_document
---

The 76ers recent Christmas Day game agains the Milwaukee Bucks got me thinking about garbage time. The Sixers held a fairly substantial lead for the whole game, but let it get close at the end (they were outscored by 15 points in the fourth quarter). 

I started to wonder, "When does garbage time start"? According to Wikipedia:

> Garbage time is a term used to refer to the period toward the end of a timed sports competition that has become a blowout when the outcome of the game has already been decided, and the coaches of one or both teams will decide to replace their best players with substitutes.

There's two questions in there. First, when is the outcome of the game decided? Second, when do coaches decide to replace their best players with substitute?

I'll take a look at these questions using the `tidyverse` for data manipulation, `nbastatR` for getting play-by-play data from the 2018-19 NBA regular season, and the `rethinking` package (which provides and interface to Stan) for modeling. 

## Setup

```{r setup, message = FALSE, warning = FALSE}

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, 
                      fig.align = "center", fig.width = 8, fig.asp = 0.618)

library(tidyverse)
library(nbastatR)
library(rethinking)
library(googledrive)
library(survival)
#devtools::instal_github("jtcies/jtcr")
library(jtcr)

theme_set(theme_jtc())
```

First we'll take grab the play-by-play for the first game from the 2018-19 regular seaons. 

```{r}

games <- seasons_schedule(seasons = 2019)

game_ids <- games$idGame

game_1  <- game_ids[[1]]

game_1_pbp <- play_by_play_v2(game_1)

game_1_pbp

```

Ah yes, I remember this game - Sixers lost to the Celtics. 

The first question we'll look is when does the coach decides to put in their substitutes, presumably because the outcome of the game has been decided and they want their less experienced players to get experience. To analyze this, we should take look at when a  

```{r g1firstaction}

game_1_first_action <- game_1_pbp %>%
    filter(!is.na(namePlayer1), !is.na(namePlayer2)) %>%
    mutate(player1 = paste0(slugTeamPlayer1, "_", namePlayer1),
           player2 = paste0(slugTeamPlayer2, "_", namePlayer2)) %>%
    select(player1, player2, minuteGame, numberPeriod) %>%
    gather(drop, player, 1:2) %>%
    select(-drop) %>%
    group_by(player) %>%
    filter(minuteGame == min(minuteGame), !is.na(player)) %>%
    arrange(minuteGame) %>%
    group_by(team = str_sub(player, 1, 3)) %>%
    mutate(player_count = row_number(),
           player = str_replace(player, "^[A-Z]{3}_", "")) %>%
    arrange(team)

knitr::kable(game_1_first_action)
```

Philadedelphia played 11 unique players, while Boston played 13 (a team can have up to 14). For Philly, the 9 players played in the first half, but 10 and 11 came in in the last two minutes of the game. For Boston, 9 also played in the first half, one showed up on the 3rd quarter, and 3 came in right at the end. How did the game end again? 

```{ri g1gt}

game_1_pbp %>% 
    fill(scoreAway, scoreHome, marginScore) %>%
    filter(minuteGame == 46.55) %>%
    select(scoreAway, scoreHome, marginScore)  %>%
    distinct() %>%
    knitr::kable()

```

Right... 

Ok, so I think there's a few things we need to figure out. First, how far in list of available players does a coach have to go before we consider them to resigned the outcome the of game. And once we figure out that number, what is the combination of score margin and time left that coaches typically reach that far in their bench. 

Below is function that gets the time of first appearance for each player, the running total of unique players that each substitute represents, and the score margin when they checked in. 

```{r gtfun}

get_garbage_time_score <- function(game_pbp) {

    # excludes OT

    player_starts <- game_pbp %>%
        fill(marginScore) %>%
        filter(!is.na(namePlayer1), !is.na(namePlayer2)) %>%
        mutate(player1 = paste0(slugTeamPlayer1, "_", namePlayer1),
               player2 = paste0(slugTeamPlayer2, "_", namePlayer2)) %>%
        select(player1, player2, minuteGame, marginScore, idGame) %>%
        gather(drop, player, 1:2) %>%
        separate(player, into = c("team", "player"), sep = "_") %>%
        select(-drop) %>%
        group_by(player) %>%
        filter(minuteGame == min(minuteGame), !is.na(player)) %>%
        ungroup() %>%
        group_by(team) %>%
        arrange(minuteGame) %>%
        mutate(n_player = row_number()) %>% 
        ungroup() %>%
        replace_na(list(marginScore = 0)) 
        
    final_margin <- game_pbp %>%
        filter(minuteGame <= 48, !is.na(marginScore)) %>% 
        arrange(desc(minuteGame)) %>%
        slice(1) %>%
        pull("marginScore")
        
    player_starts %>%
        mutate(final_margin = final_margin)

}

get_garbage_time_score(game_1_pbp) %>%
    knitr::kable()
```

Whena applying that function to the first game, we can see that garbage time started when the 10th Philadelphia and 11th Boston player came in - about a minute and half left and Boston up by 16. Now that we know it works, we can apply to it each gmae of the season. 

```{r getgt}
# you can use this below to download yourself
# it's a big file so I've uploaded it to my google drive 

# game_ids <- games$idGame

# games_pbp <- purrr::map_dfr(game_ids, play_by_play_v2)

# if you want to download yourself, you can use this code
#game_ids <- games$idGame

# games_pbp <- purrr::map_dfr(game_ids, play_by_play_v2)

# i've already uploaded the full play by play for 2019 to my google drive. 
# you can access here: https://drive.google.com/open?id=1J4oHD-8ILt9nOAVgw8GoEyBtct8BO4y8

temp_dir <- tempdir()

drive_download(
    file = as_id("1J4oHD-8ILt9nOAVgw8GoEyBtct8BO4y8"),
    path = file.path(temp_dir, "nba_pbp_2019.csv"),
    overwrite = TRUE
)

games_pbp <- read_csv(file.path(temp_dir, "nba_pbp_2019.csv"))

# length(unique(games_pbp$idGame))
# [1] 1227 -  missing three games

games_gt <- games_pbp %>% 
    split(.$idGame) %>% 
    map_dfr(get_garbage_time_score)
```

```{r}

games_gt %>%
    filter(minuteGame < 48,
           n_player > 5) %>%
    ggplot(aes(minuteGame, abs(marginScore))) +
        geom_jitter() +
        facet_wrap(~n_player) +
        xlim(c(0, 48)) +
        annotate("rect", xmin = 36, ymin = 10, xmax = 48, ymax = Inf,
                  alpha = 0.2, fill = "red") +
        annotate("rect", xmin = 45, ymin = 0, xmax = 48, ymax = Inf,
                  alpha = 0.2, fill = "blue") +
        labs(y = "Score margin",
             x = "minute",
             title = "First appearance of teams substitutes")

```

The chart above shows the first appearance of each teams 6th through 14th players. The red block shows the last quarter and margin of at least 10, and the blue shows the last three minutes. These are just to highlight the most conservative estimates of garbage time. 

For these purposes, it looks like we say that it's garbage time if the 10th player sees their first action in the fourth quarter with a margin of at least 10 points or if the 10th player sees their first action with less than three minutes left in the game. If we just went with the 10th player, we'd capture too many games where the 10th player checks in during the first half, which would never be considered garbage time. If we went with the 13th or 14th player, we'd miss a whole bunch of games that never saw that many unique players. So combination is required. 

Let's apply that definition to all of the games to see when garbage time starts or what the final margin was if it didn't happen. 

```{r}

# there's probably a more elegant way to do this. 
# Please let me know if you think of one. 

# only games with no overtime

no_ot <- games_gt %>% 
    group_by(idGame) %>% 
    filter(max(minuteGame) <= 48) %>% 
    ungroup() 

gt <- no_ot %>%
    mutate(gt = if_else(n_player >= 12 & minuteGame >= 36, 1L, 0L)) 

# point at which gt kicked in
gt_yes <- gt %>% 
    filter(gt == 1) %>% 
    arrange(minuteGame, desc(marginScore)) %>% 
    distinct(idGame, .keep_all = TRUE) %>% 
    select(idGame, minuteGame, marginScore, gt)

# games with no gt
gt_no <- gt %>% 
    anti_join(gt_yes, by = "idGame") %>% 
    distinct(idGame, .keep_all = TRUE) %>% 
    mutate(marginScore = final_margin,
           minuteGame = 48) %>% 
    select(idGame, marginScore, minuteGame, gt)
    
all_gt <- bind_rows(gt_yes, gt_no)

# what percent of games have garbage time? 
mean(all_gt$gt)
# [1] 0.3388023

all_gt %>%
    filter(gt == 1) %>% 
    ggplot(aes(minuteGame, abs(marginScore))) +
        geom_jitter() +
        labs(x = "minute",
             y = "score margin",
             title = "When does garbage time start?",
             subtitle = "based on 10th player making appearance in 4th quarter")

```


This looks like it is consistent with my prior that the lead would have to be 25 or 30 points in the beginning of the fourth quarter but moves closer to zero as the game gets closer to the end. 

What is the distribution of final scores for games with no garbage time? 

```{r}

all_gt %>% 
    filter(gt == 0) %>% 
    ggplot(aes(abs(marginScore))) +
        geom_histogram(binwidth = 1, fill = jtc_primary[2]) +
        labs(
            x = "final margin",
            title = "Distribution of final score margin for games with no garbage time"
        )

```

Anything less than 10 makes sense. I'm somewhat skeptical that games with a greater than 20 point margin never went into garbage time, but it's probably just a limitation of our definition. We'll keep them in for now.


# Fitting a model

We're going to use a Cox Proportional Hazard[link] surival model for this. First we will use the `surival package` and then we will try a Bayesian approach. 

```{r}

cox_fit <- coxph(Surv(minuteGame, gt) ~ log(marginScore + 0.000001), data = all_gt)

mean_gt <- all_gt %>% 
  group_by(marginScore = abs(marginScore)) %>% 
  summarise(avg = mean(gt))

cox_sim <- crossing(
  marginScore = log(seq(0.000001, 30, by = 5))
)

cox_pred <- survfit(cox_fit, newdata = cox_sim)

cox_df <- as_tibble(cox_pred$cumhaz)

colnames(cox_df) <- cox_sim$marginScore

surv_preds <- cox_df %>%
    mutate(minuteGame = cox_pred$time) %>%
    gather(marginScore, surv_prob, -minuteGame)

surv_preds %>%
    ggplot(aes(minuteGame, surv_prob, color = factor(marginScore))) +
        geom_line() +
        expand_limits(y = 0)

```

```{r gtmod}

gt_list <- list(
    minuteGame = all_gt$minuteGame,
    marginScore = abs(all_gt$marginScore),

)

```

Plotting the posterior shows that, according to the model, coaches keep their main players in if the margin is less than 20 points. With less than 2 mintues to go, it moves quickly to but never quite reaches zero. 

## When is a game decided? 

The other way to look at garbage time is to examine at what point the outcome is already decided. Below I calculate the margin above which a percentage of games end with the leading team winning. I use a 90%, 95%, and 99% threshold.

```{r}

fourth_qtr_scores <- games_pbp %>%
    mutate(minuteGame = round(minuteGame, 1)) %>%
    complete(idGame, minuteGame = seq(36, 48, by = 0.1)) %>%
    group_by(idGame) %>%
    fill(marginScore) %>%
    arrange(minuteGame, desc(marginScore)) %>%
    distinct(idGame, minuteGame, marginScore) %>%
    filter(minuteGame >= 36, minuteGame <= 48)

final_scores <- fourth_qtr_scores %>%
    filter(minuteGame == max(minuteGame)) %>%
    select(idGame, final_score = marginScore)

fourth_qtr_w_final <- fourth_qtr_scores %>%
    inner_join(final_scores, by = "idGame") %>%
    mutate(home_win = final_score > 0,
           home_winning = marginScore > 0,
           winning_team_ahead = home_win == home_winning)

percent_decided <- fourth_qtr_w_final %>%
    group_by(minuteGame, margin = abs(marginScore)) %>%
    summarise(win_rate = mean(winning_team_ahead)) %>%
    mutate(
        pct90 = win_rate > .9,
        pct95 = win_rate > .95,
        pct99 = win_rate > .99
    ) %>%
    gather(metric, val, pct90:pct99) %>%
    filter(val) %>%
    group_by(minuteGame, metric) %>%
    filter(margin == min(margin)) 

preds %>% 
    group_by(minute = minute + 36) %>% 
    summarise(
        mean = mean(val), 
        sd = sd(val)
    ) %>% 
    ggplot(aes(minute, mean)) +
        geom_line() +
        geom_ribbon(aes(ymin = mean - 2 * sd, ymax = mean + 2 * sd), alpha = 0.2) +
        geom_line(data = percent_decided, aes(minuteGame, margin, color = metric))


```

Unsuprisingly coaches are more conversative about starting garbage time than the percentages indicate that the game has already been decided. 

## Other questions?

- What are other ways to define garbage time start (than a player's first action)? 
- How do coaches differ in whether or not they go into garbage time mode? 
- Has the boundry for garbage time changed over time? 
- How close does the score have to get for a coach to put their starters back in?
- How to factor in games going to overtime? 
- When should garbage time actually kick in (i.e. when should a game be considered decided)? 

